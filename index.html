<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <meta name="author" content="Theodore Beers" />
    <title>Unicode Collation for Dummies</title>
    <style>
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      div.columns {
        display: flex;
        gap: min(4vw, 1.5em);
      }
      div.column {
        flex: auto;
        overflow-x: auto;
      }
      div.hanging-indent {
        margin-left: 1.5em;
        text-indent: -1.5em;
      }
      /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
      ul.task-list[class] {
        list-style: none;
      }
      ul.task-list li input[type="checkbox"] {
        font-size: inherit;
        width: 0.8em;
        margin: 0 0.8em 0.2em -1.6em;
        vertical-align: middle;
      }
      .display.math {
        display: block;
        text-align: center;
        margin: 0.5rem auto;
      }
      /* CSS for syntax highlighting */
      html {
        -webkit-text-size-adjust: 100%;
      }
      pre > code.sourceCode {
        white-space: pre;
        position: relative;
      }
      pre > code.sourceCode > span {
        display: inline-block;
        line-height: 1.25;
      }
      pre > code.sourceCode > span:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode > span {
        color: inherit;
        text-decoration: inherit;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        pre > code.sourceCode {
          white-space: pre-wrap;
        }
        pre > code.sourceCode > span {
          text-indent: -5em;
          padding-left: 5em;
        }
      }
      pre.numberSource code {
        counter-reset: source-line 0;
      }
      pre.numberSource code > span {
        position: relative;
        left: -4em;
        counter-increment: source-line;
      }
      pre.numberSource code > span > a:first-child::before {
        content: counter(source-line);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        background-color: #232629;
        color: #7a7c7d;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #7a7c7d;
        padding-left: 4px;
      }
      div.sourceCode {
        color: #cfcfc2;
        background-color: #232629;
      }
      @media screen {
        pre > code.sourceCode > span > a:first-child::before {
          text-decoration: underline;
        }
      }
      code span {
        color: #cfcfc2;
      } /* Normal */
      code span.al {
        color: #95da4c;
        background-color: #4d1f24;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #3f8058;
      } /* Annotation */
      code span.at {
        color: #2980b9;
      } /* Attribute */
      code span.bn {
        color: #f67400;
      } /* BaseN */
      code span.bu {
        color: #7f8c8d;
      } /* BuiltIn */
      code span.cf {
        color: #fdbc4b;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #3daee9;
      } /* Char */
      code span.cn {
        color: #27aeae;
        font-weight: bold;
      } /* Constant */
      code span.co {
        color: #7a7c7d;
      } /* Comment */
      code span.cv {
        color: #7f8c8d;
      } /* CommentVar */
      code span.do {
        color: #a43340;
      } /* Documentation */
      code span.dt {
        color: #2980b9;
      } /* DataType */
      code span.dv {
        color: #f67400;
      } /* DecVal */
      code span.er {
        color: #da4453;
        text-decoration: underline;
      } /* Error */
      code span.ex {
        color: #0099ff;
        font-weight: bold;
      } /* Extension */
      code span.fl {
        color: #f67400;
      } /* Float */
      code span.fu {
        color: #8e44ad;
      } /* Function */
      code span.im {
        color: #27ae60;
      } /* Import */
      code span.in {
        color: #c45b00;
      } /* Information */
      code span.kw {
        color: #cfcfc2;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #cfcfc2;
      } /* Operator */
      code span.ot {
        color: #27ae60;
      } /* Other */
      code span.pp {
        color: #27ae60;
      } /* Preprocessor */
      code span.re {
        color: #2980b9;
        background-color: #153042;
      } /* RegionMarker */
      code span.sc {
        color: #3daee9;
      } /* SpecialChar */
      code span.ss {
        color: #da4453;
      } /* SpecialString */
      code span.st {
        color: #f44f4f;
      } /* String */
      code span.va {
        color: #27aeae;
      } /* Variable */
      code span.vs {
        color: #da4453;
      } /* VerbatimString */
      code span.wa {
        color: #da4453;
      } /* Warning */
    </style>
    <link rel="stylesheet" href="reset.css" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Cascadia+Code:ital,wght@0,200..700;1,200..700&family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Unicode Collation for Dummies</h1>
      <p class="author">Theodore Beers</p>
      <p class="date">August 2025</p>
    </header>
    <p>
      This post is meant as an introduction to the
      <a href="https://www.unicode.org/reports/tr10/"
        >Unicode Collation Algorithm</a
      >
      (UCA), a standardized solution to a problem that turns out to be
      surprisingly complex: how can we alphabetically sort items of text when
      the characters go beyond the basic Latin alphabet? Let’s find out…
    </p>
    <p>
      <em
        >Sidebar: I maintain a simple but conformant &amp; performant
        implementation of the UCA in Rust, called
        <a href="https://github.com/theodore-s-beers/feruca">feruca</a> ; and I
        recently adapted it to Zig, in a library called
        <a href="https://github.com/theodore-s-beers/later">later</a> . Code
        examples in this post will be in Zig. You may also like to visit my “<a
          href="https://www.theobeers.com/allsorts/"
          >Text Sorting Playground</a
        > ,” a little web app that demonstrates the differences among a few
        approaches to collation.</em
      >
    </p>
    <h2 id="introduction">Introduction</h2>
    <p>
      Given two strings of UTF-8-encoded text—let’s say, for example, the names
      “Edgar” and “Frank”—it is trivial for a computer to determine which of
      them should come first alphabetically. If we look at a representation of
      those strings as arrays of byte values, we find that “Edgar” is (in
      hexadecimal) <code>[45, 64, 67, 61, 72]</code>; and “Frank” is
      <code>[46, 72, 61, 6E, 6B]</code>. Simple array comparison yields a
      difference at index 0, with E being “less than” F, so that Edgar sorts
      before Frank. This is a happy consequence of the fact that early text
      encoding schemes—notably ASCII, which was inherited by Unicode—assigned
      numerical values to the letters that they included in
      <em>a kind of</em> alphabetical order. There is still the issue that ASCII
      groups all the uppercase letters before all the lowercase letters, so
      that, for example, “earnest” will sort after “Frank.” But at least we have
      an alphabetical order of byte values within the uppercase and lowercase
      groups.
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Edgar</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Frank</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Zardoz</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>earnest # Not ideal</span></code></pre>
    </div>
    <p>
      Back to the larger problem: what happens if we add, say, “Élodie” to our
      list of names? A human will understand intuitively that E and É belong
      together as variants of the same letter—perhaps with the accented version
      to come after the unaccented, alphabetically. But how can we establish
      this rigorously in a way that facilitates automated sorting? The letter É
      has two main representations in Unicode: either as a single character,
      <code>U+00C9</code>, for a Latin capital E with an acute accent; or as a
      combination of two characters, <code>U+0045</code> and
      <code>U+0301</code>, accounting for the base letter and the accent,
      respectively. (I wanted to bring up the “decomposed representation” as
      early as possible in this post, since it’s the form that we generally want
      for Unicode sorting/collation. More on this later…)
    </p>
    <p>
      Both of these representations will break the naïve approach to sorting, in
      their own ways. <code>C9</code> as a byte value is greater than any in the
      ASCII/Basic Latin table, meaning that “Élodie” would sort after, say,
      “Zardoz.” Using the decomposed form seems promising—the first byte value
      is simply that of E, appropriate for sorting—but the combining accent
      character introduces new problems. <code>0x301</code>
      is too large to be represented in a single byte, so in UTF-8 it becomes
      <code>[CC, 81]</code>. “Élodie” in decomposed form is made up of seven
      code points, in eight bytes in the common encoding, where we perceive only
      six letters. It should be obvious how this would wreak havoc on a sorting
      algorithm that does nothing more than array comparison on the byte values.
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Edgar</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>Zardoz</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>earnest</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>Élodie  # Assuming form NFC</span></code></pre>
    </div>
    <p>
      <strong>We need something better.</strong> Unicode is a large and complex
      system, and if we want a way of mapping code points to collation weights,
      it will have to be defined explicitly. That’s where the Unicode Collation
      Algorithm comes in.
    </p>
    <h2 id="basic-idea">Basic Idea</h2>
    <p>
      <em
        >Some of what follows is oversimplification. If you’re already familiar
        with this subject, please try to be charitable. I’ll go into greater
        detail as the post progresses.</em
      >
    </p>
    <p>
      The central concept of Unicode collation is that one character might
      belong before/after another character on different bases. They may
      represent fundamentally different letters, like E and F; they may be
      different forms of something understood to be the “same” letter, like E
      and É; or they may be closer still, differing only in case, like E and e.
      Of course, languages and writing systems are extremely diverse, and not
      all of them even have a concept of uppercase vs. lowercase. But it turns
      out that allowing for a hierarchy of three (or sometimes four) levels of
      collation difference between code points is generally sufficient to get
      the job done.
    </p>
    <p>
      In a writing system like the Latin alphabet, these levels are indeed
      organized as I hinted above: the <em>primary</em> level of collation
      distinguishes among different base letters; the <em>secondary</em> level
      distinguishes among diacritics, like accents; and the <em>tertiary</em>
      level accounts for case differences. If we assign to each code point in
      the Unicode tables a set of primary, secondary, and tertiary
      <em>collation weights</em>, we can then decide which of them sorts before
      the other by comparing their weights one level at a time. And this can be
      extrapolated to collate entire strings.
    </p>
    <p>
      Let’s look at some real examples from the
      <strong>Default Unicode Collation Element Table</strong> (<a
        href="https://www.unicode.org/Public/UCA/latest/allkeys.txt"
        >DUCET</a
      >), one of the standard documents that Unicode publishes in order to make
      this possible. NB, the following lines are not necessarily adjacent in the
      original; I’m pulling examples from different areas.
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>0301  ; [.0000.0024.0002]                  # COMBINING ACUTE ACCENT</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>0045  ; [.23E7.0020.0008]                  # LATIN CAPITAL LETTER E</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>00C9  ; [.23E7.0020.0008][.0000.0024.0002] # LATIN CAPITAL LETTER E WITH ACUTE</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>0058  ; [.2660.0020.0008]                  # LATIN CAPITAL LETTER X</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>1D54F ; [.2660.0020.000B]                  # MATHEMATICAL DOUBLE-STRUCK CAPITAL X</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>007A  ; [.2682.0020.0002]                  # LATIN SMALL LETTER Z</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>0642  ; [.2AF9.0020.0002]                  # ARABIC LETTER QAF</span></code></pre>
    </div>
    <p>
      What we find in each line is the code point; a semicolon separator; one or
      more <em>sets of weights</em>, each consisting of primary, secondary, and
      tertiary parts; and a comment giving the official name of the Unicode
      scalar value. <em>All numerical values are in hexadecimal.</em> We can
      look at one in greater detail:
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>0058  ; [.2660.0020.0008] # LATIN CAPITAL LETTER X</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>^         ^    ^    ^       ^</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>cp        p    s    t       name</span></code></pre>
    </div>
    <p>
      Hopefully you can see already where this is going. If we want to determine
      the proper lexicographical order of two characters—to take the simplest
      scenario possible—we can find their collation weights and compare them at
      the primary, then the secondary, then the tertiary level, returning as
      soon as we find a difference. Look, for example, at the respective weights
      of an ordinary capital letter X and the “mathematical double-struck
      capital X,” i.e., the logo of the site formerly known as Twitter. They
      differ only at the tertiary level: both belong to the X family, and
      neither has a diacritic.
    </p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>0058  ; [.2660.0020.0008] # LATIN CAPITAL LETTER X</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>1D54F ; [.2660.0020.000B] # MATHEMATICAL DOUBLE-STRUCK CAPITAL X</span></code></pre>
    </div>
    <p>
      The reality of Unicode collation ends up being significantly more complex
      than this, but we can start on the happy path.
    </p>
    <h2 id="simple-but-real-examples">Simple but Real Examples</h2>
    <h3 id="élodie-and-frank">Élodie and Frank</h3>
    <p>
      Armed with our fledgling understanding of how the Unicode Collation
      Algorithm works, let’s return to the test case of placing the names
      “Élodie” and “Frank” in alphabetical order. We’ll begin by representing
      them as arrays of code points, each of which has its assigned collation
      weights in the standard table.
    </p>
    <p>
      First, Élodie (note that we use the <em>decomposed</em> form of É; this is
      a crucial part of the UCA):
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>0045  ; [.23E7.0020.0008] # LATIN CAPITAL LETTER E</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>0301  ; [.0000.0024.0002] # COMBINING ACUTE ACCENT</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>006C  ; [.24BC.0020.0002] # LATIN SMALL LETTER L</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>006F  ; [.252C.0020.0002] # LATIN SMALL LETTER O</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>0064  ; [.23CA.0020.0002] # LATIN SMALL LETTER D</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>0069  ; [.2473.0020.0002] # LATIN SMALL LETTER I</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>0065  ; [.23E7.0020.0002] # LATIN SMALL LETTER E</span></code></pre>
    </div>
    <p>Next, Frank:</p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>0046  ; [.2422.0020.0008] # LATIN CAPITAL LETTER F</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>0072  ; [.2584.0020.0002] # LATIN SMALL LETTER R</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>0061  ; [.2380.0020.0002] # LATIN SMALL LETTER A</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>006E  ; [.2505.0020.0002] # LATIN SMALL LETTER N</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>006B  ; [.24A8.0020.0002] # LATIN SMALL LETTER K</span></code></pre>
    </div>
    <p>
      Since the first round of collation checking will be on the primary weights
      of these two words, we can pull those out and make a simpler array of
      primaries for each word, called a <em>sort key</em>.
    </p>
    <p>
      It’s important to note that <em>only nonzero weights</em> are considered
      here. As you can see, the “combining acute accent” character has no
      primary weight. We ignore that zero when constructing the sort key. This
      is necessary so that, for example, two words like “Maria” and “María,”
      which differ only by an accent, are <em>identical</em> at the primary
      level. Allowing a zero primary weight for an accent character to enter the
      sort key would immediately break collation. Anyway, our primary-level sort
      keys for “Élodie” and “Frank” are as follows:
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>[23E7, 24BC, 252C, 23CA, 2473, 23E7] # Élodie</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>[2422, 2584, 2380, 2505, 24A8]       # Frank</span></code></pre>
    </div>
    <p>
      You don’t have to be a genius to figure this out. We’re back to
      straightforward array comparison, and we can reach a decision at index 0:
      “Élodie” belongs first.
    </p>
    <h3 id="élodie-and-elodie">Élodie and Elodie</h3>
    <p>
      Now for a bit of a contrived example: what if we also had the name
      “Elodie” without the accent? How would collation proceed? We already know
      what the primary-level sort key would be for both words:
    </p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>[23E7, 24BC, 252C, 23CA, 2473, 23E7] # Élodie or Elodie (primary)</span></code></pre>
    </div>
    <p>
      That is, comparison at the primary level would yield no difference. We
      then move to the secondary level, again building sort keys out of all
      nonzero weights:
    </p>
    <div class="sourceCode" id="cb10">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>[0020, 0024, 0020, 0020, 0020, 0020, 0020] # Élodie (secondary)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>[0020, 0020, 0020, 0020, 0020, 0020]       # Elodie (secondary)</span></code></pre>
    </div>
    <p>
      Now we see that “Élodie” has an extra element in its list of secondary
      weights, and it is higher than the others. We reach a decision at index 1
      in the secondary sort key: “Elodie” (sans accent) belongs first.
    </p>
    <h3 id="frank-and-frank">Frank and frank</h3>
    <p>
      For the sake of thoroughness, let’s also consider two words that differ
      only in case, i.e., at the tertiary level. The name “Frank” and the common
      adjective “frank” will work nicely for this. We can add to the previous
      list of weights the values for lowercase f:
    </p>
    <div class="sourceCode" id="cb11">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>0066  ; [.2422.0020.0002] # LATIN SMALL LETTER F</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>0046  ; [.2422.0020.0008] # LATIN CAPITAL LETTER F</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>0072  ; [.2584.0020.0002] # LATIN SMALL LETTER R</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>0061  ; [.2380.0020.0002] # LATIN SMALL LETTER A</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>006E  ; [.2505.0020.0002] # LATIN SMALL LETTER N</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>006B  ; [.24A8.0020.0002] # LATIN SMALL LETTER K</span></code></pre>
    </div>
    <p>The primary-level sort key will not yield a difference:</p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>[2422, 2584, 2380, 2505, 24A8] # Frank or frank (primary)</span></code></pre>
    </div>
    <p>Nor will the secondary-level sort key:</p>
    <div class="sourceCode" id="cb13">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>[0020, 0020, 0020, 0020, 0020] # Frank or frank (secondary)</span></code></pre>
    </div>
    <p>But we finally have something at the tertiary level:</p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>[0008, 0002, 0002, 0002, 0002] # Frank (tertiary)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>[0002, 0002, 0002, 0002, 0002] # frank (tertiary)</span></code></pre>
    </div>
    <p>
      At index 0 in the tertiary sort key, we see that “frank” belongs first.
    </p>
    <p>
      <em
        >This is a noteworthy difference between the Unicode Collation Algorithm
        and ASCII sorting: the order of the cases is reversed! An implementation
        of the UCA can of course make this configurable; it’s trivial to set a
        flag and have comparisons reversed at the tertiary level. But the
        difference in default behavior is interesting nonetheless.</em
      >
    </p>
    <h2 id="the-plot-thickens">The Plot Thickens</h2>
    <p>
      Some readers may like to stop here. I’ve given you enough of a primer that
      you could explain the general idea behind Unicode collation and how it
      works. You could even, with reference to a copy of
      <code>allkeys.txt</code> (i.e., the DUCET file), perform manual collation
      of one string against another. That should be more than enough to impress
      someone at a cocktail party.
    </p>
    <p>
      But I want to go on and show, in greater detail, what is actually involved
      in writing a conformant implementation of the UCA—i.e., an implementation
      that passes the punishingly rigorous
      <a href="https://www.unicode.org/Public/UCA/latest/CollationTest.html"
        >conformance tests</a
      >
      that are published alongside the technical standard. So if you’re
      interested in digging deeper, feel free to stick around and keep reading.
    </p>
    <p>
      I think it will be helpful for most of the remainder of this post to be
      guided by the actual code of the collation routine that I wrote for my Zig
      library, <a href="https://github.com/theodore-s-beers/later">later</a>.
      This comes from <code>src/collator.zig</code>:
    </p>
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode zig"
      ><code class="sourceCode zig"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> collateFallible(<span class="va">self</span><span class="op">:</span> <span class="op">*</span>Collator<span class="op">,</span> a<span class="op">:</span> []<span class="at">const</span> <span class="dt">u8</span><span class="op">,</span> b<span class="op">:</span> []<span class="at">const</span> <span class="dt">u8</span>) <span class="op">!</span>std<span class="op">.</span>math<span class="op">.</span>Order {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (std<span class="op">.</span>mem<span class="op">.</span>eql(<span class="dt">u8</span><span class="op">,</span> a<span class="op">,</span> b)) <span class="cf">return</span> <span class="op">.</span>eq;</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> decode<span class="op">.</span>bytesToCodepoints(<span class="op">&amp;</span><span class="va">self</span><span class="op">.</span>a_chars<span class="op">,</span> a);</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> decode<span class="op">.</span>bytesToCodepoints(<span class="op">&amp;</span><span class="va">self</span><span class="op">.</span>b_chars<span class="op">,</span> b);</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASCII fast path</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (ascii<span class="op">.</span>tryAscii(<span class="va">self</span><span class="op">.</span>a_chars<span class="op">.</span>items<span class="op">,</span> <span class="va">self</span><span class="op">.</span>b_chars<span class="op">.</span>items)) <span class="op">|</span>ord<span class="op">|</span> <span class="cf">return</span> ord;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> normalize<span class="op">.</span>makeNFD(<span class="va">self</span><span class="op">,</span> <span class="op">&amp;</span><span class="va">self</span><span class="op">.</span>a_chars);</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> normalize<span class="op">.</span>makeNFD(<span class="va">self</span><span class="op">,</span> <span class="op">&amp;</span><span class="va">self</span><span class="op">.</span>b_chars);</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> offset <span class="op">=</span> <span class="cf">try</span> prefix<span class="op">.</span>findOffset(<span class="va">self</span>); <span class="co">// Default 0</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Prefix trimming may reveal that one list is a prefix of the other</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="va">self</span><span class="op">.</span>a_chars<span class="op">.</span>items[offset<span class="op">..</span>]<span class="op">.</span>len <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> <span class="va">self</span><span class="op">.</span>b_chars<span class="op">.</span>items[offset<span class="op">..</span>]<span class="op">.</span>len <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> util<span class="op">.</span>cmp(<span class="dt">usize</span><span class="op">,</span> <span class="va">self</span><span class="op">.</span>a_chars<span class="op">.</span>items<span class="op">.</span>len<span class="op">,</span> <span class="va">self</span><span class="op">.</span>b_chars<span class="op">.</span>items<span class="op">.</span>len);</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> cea<span class="op">.</span>generateCEA(<span class="va">self</span><span class="op">,</span> offset<span class="op">,</span> <span class="cn">false</span>); <span class="co">// a</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> cea<span class="op">.</span>generateCEA(<span class="va">self</span><span class="op">,</span> offset<span class="op">,</span> <span class="cn">true</span>); <span class="co">// b</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> ord <span class="op">=</span> sort_key<span class="op">.</span>cmpIncremental(<span class="va">self</span><span class="op">.</span>a_cea<span class="op">.</span>items<span class="op">,</span> <span class="va">self</span><span class="op">.</span>b_cea<span class="op">.</span>items<span class="op">,</span> <span class="va">self</span><span class="op">.</span>shifting);</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (ord <span class="op">==</span> <span class="op">.</span>eq <span class="kw">and</span> <span class="va">self</span><span class="op">.</span>tiebreak) <span class="cf">return</span> util<span class="op">.</span>cmpArray(<span class="dt">u8</span><span class="op">,</span> a<span class="op">,</span> b);</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ord;</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>
      This can be broken down into eight steps, some of them quite simple,
      others horrifyingly complex:
    </p>
    <ol type="1">
      <li>
        <p>Handle edge cases (i.e., equal is equal and returns immediately).</p>
      </li>
      <li>
        <p>
          Ensure that the input strings are valid UTF-8 (applying fixes if
          needed), and decode from bytes to Unicode scalar values.
        </p>
      </li>
      <li>
        <p>
          See if a result can be reached by comparing ASCII-range characters in
          the two strings; this is often not possible, but when it is, it saves
          so much computation that it’s an indispensable code path.
        </p>
      </li>
      <li>
        <p>
          If we need to continue with the UCA proper, begin by ensuring that
          both strings have all their characters in the canonical decomposed
          form, i.e.,
          <a
            href="https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization"
            >NFD</a
          >.
        </p>
      </li>
      <li>
        <p>
          Check if the two strings have a prefix in common that can safely be
          ignored in collation. Doing this while conforming to the standard is
          more difficult than it seems, for reasons that I may not even be able
          to cover in this post. Prefix trimming can sometimes produce a
          collation result on its own, if one string turns out to be a prefix of
          the other.
        </p>
      </li>
      <li>
        <p>
          Generate the <em>collation element array</em>. This process is by far
          the most complex part of the UCA. It corresponds to the step shown
          above (in a very basic case), where we looked up the collation weights
          associated with each code point in each of the strings being compared.
          There are many subtleties to consider here; I’ll get into it below.
        </p>
      </li>
      <li>
        <p>
          Process the collation element arrays into <em>sort keys</em>, checking
          one level at a time until a result is yielded. By this point, most of
          the hard work has been done.
        </p>
      </li>
      <li>
        <p>
          If the sort keys somehow came back identical, there is a final option
          to use naïve comparison of the input strings as a tiebreaker.
        </p>
      </li>
    </ol>
    <p>
      We can look at these steps one-by-one—at least, in those cases where
      there’s anything worth saying. One fun part of implementing the UCA in Zig
      was that I chose not to use any dependencies outside of the standard
      library. So I dealt with problems like UTF-8 validation and decoding and
      NFD normalization in my own code. I’ll show snippets of how these
      components work. Still, the main focus will be on the core logic of the
      UCA.
    </p>
    <h2 id="from-utf-8-to-code-points">From UTF-8 to Code Points</h2>
    <p>
      I don’t have a lot to say here, since UTF-8 validation/decoding is a
      well-understood problem with many solutions available in the public
      domain. The one that I chose to adapt to Zig, however, is probably one of
      the most elegant pieces of code I’ve ever seen. It’s a famous UTF-8
      decoder written in C by Björn Höhrmann, subsequently improved by Rich
      Felker (creator/maintainer of musl).
    </p>
    <p>
      This decoder is based on a deterministic finite automaton, i.e. a state
      machine, wherein each byte of UTF-8 that is encountered causes a certain
      state transition. There is a “home state,” or an “accept state,” which is
      reached each time that a full code point has been processed. This can
      happen, of course, after anything from one to four bytes.
    </p>
    <p>
      Any invalid sequence brings the DFA into a “reject state,” which is
      normally handled by having the decoder emit the “Unicode replacement
      character,” <code>U+FFFD</code>. What I find brilliant, though, is that
      validation of UTF-8 sequences is accomplished hand-in-hand with
      determining the code points. That is, each time that the DFA reaches the
      “accept state,” the function also has access to the value of the code
      point that has just been completed. For a case like Unicode normalization,
      this is perfect: what we want for the algorithm is a list of code points
      in <code>u32</code> (or <code>u21</code>, but you get the idea). Below you
      can see what I mean; I’ve added some comments for clarity.
    </p>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode zig"
      ><code class="sourceCode zig"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> bytesToCodepoints(codepoints<span class="op">:</span> <span class="op">*</span>std<span class="op">.</span>ArrayList(<span class="dt">u32</span>)<span class="op">,</span> input<span class="op">:</span> []<span class="at">const</span> <span class="dt">u8</span>) <span class="op">!</span><span class="dt">void</span> {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>   <span class="co">// For performance reasons, we keep reusing a list of code points</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>   codepoints<span class="op">.</span>clearRetainingCapacity();</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">try</span> codepoints<span class="op">.</span>ensureTotalCapacity(input<span class="op">.</span>len);</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Start with the &quot;accept state&quot; and 0 code point value</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>   <span class="at">var</span> state<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> UTF8_ACCEPT;</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>   <span class="at">var</span> codepoint<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Iterate over bytes of the string</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> (input) <span class="op">|</span>b<span class="op">|</span> {</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Get the next state and updated code point value</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> new_state <span class="op">=</span> decode(<span class="op">&amp;</span>state<span class="op">,</span> <span class="op">&amp;</span>codepoint<span class="op">,</span> b);</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">// If we reached an &quot;end state,&quot; handle it</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (new_state <span class="op">==</span> UTF8_REJECT) {</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>         codepoints<span class="op">.</span>appendAssumeCapacity(REPLACEMENT);</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>         state <span class="op">=</span> UTF8_ACCEPT;</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span> <span class="cf">if</span> (new_state <span class="op">==</span> UTF8_ACCEPT) {</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>         codepoints<span class="op">.</span>appendAssumeCapacity(codepoint);</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Otherwise continue to the next byte (of a multi-byte character)</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>   <span class="co">// If we ended in an incomplete sequence, emit replacement</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> (state <span class="op">!=</span> UTF8_ACCEPT) codepoints<span class="op">.</span>appendAssumeCapacity(REPLACEMENT);</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>
      I’ve left out the <code>decode</code> function, but you can look into this
      further if you’re curious and haven’t seen an implementation of this style
      of UTF-8 decoder before. The basic idea is that each byte from the input
      string is treated as an index into a table in order to compute the next
      state and value of the code point variable.
    </p>
    <p>
      Fortunately, this is also quite performant! It’s <em>not</em> the fastest
      possible approach. Daniel Lemire has written a few blog posts (<a
        href="https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/"
        >example</a
      >), and at least one academic paper, on the subject of maximizing
      performance in UTF-8 validation/decoding. But Höhrmann’s decoder continues
      to be popular because it’s good enough, easy to understand, and elegant.
      Everyone should give it a try at some point.
    </p>
    <h2 id="nfd-normalization">NFD Normalization</h2>
    <p>
      As I mentioned earlier, Unicode collation requires that the characters in
      each string be <em>decomposed</em> and <em>in canonical order</em>. This
      means that any code point that is considered (per the Unicode standard) to
      be a composition of multiple other, lower-level code points must be broken
      down into those. I gave a simple example: “É,” the Latin-script capital E
      with an acute accent. This letter can be, and most often is, represented
      by the single code point <code>U+00C9</code>. In fact, the great majority
      of digital text that we encounter these days is in the UTF-8 encoding and
      in form NFC, i.e., with characters <em>composed</em> into shorter
      representations where possible, and upholding
      <em>canonical equivalence</em>. (That is, characters that are considered
      equivalent are guaranteed to be represented the same way in form NFC.)
    </p>
    <p>
      Back to “É,” though: it can also be represented via two code points,
      <code>U+0045</code> for the capital letter E, and <code>U+0301</code> for
      the combining acute accent. This is another canonical Unicode form, called
      NFD. I’m sure you get the idea, at least in a basic sense. Whereas NFC has
      composed characters, NFD has them decomposed and with the constituent
      parts in a standard order. You can perhaps also understand how this is
      helpful—necessary, in fact—for proper sorting. Breaking down “É” into “E
      followed by an acute accent” is what allowed us to derive identical sort
      keys for “Élodie” and “Elodie” at the primary level, and for the accent to
      make the collation decision between the two words at just the right spot
      (i.e., just after the initial letter/index).
    </p>
    <p>
      I worry this discussion could become dense, but on some level it should be
      straightforward enough. We deal with mostly NFC text data in the wild, and
      we need to convert to NFD to apply the Unicode Collation Algorithm. How
      can we do that? It ends up being one of those problems that teaches you a
      lot about the Unicode standard if you want to write your own
      implementation. This is because you need to be able to determine, for any
      code point, what its canonical decomposition is (if any); and how those
      decomposed parts must be ordered. I tried to keep this understandable in
      my code, with a high-level function that goes through the different steps
      of the NFD conversion process:
    </p>
    <div class="sourceCode" id="cb17">
      <pre
        class="sourceCode zig"
      ><code class="sourceCode zig"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> makeNFD(coll<span class="op">:</span> <span class="op">*</span>Collator<span class="op">,</span> input<span class="op">:</span> <span class="op">*</span>std<span class="op">.</span>ArrayList(<span class="dt">u32</span>)) <span class="op">!</span><span class="dt">void</span> {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> (<span class="cf">try</span> fcd(coll<span class="op">,</span> input<span class="op">.</span>items)) <span class="cf">return</span>;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">try</span> decompose(coll<span class="op">,</span> input);</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>   reorder(input<span class="op">.</span>items);</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>
      As you can see, we have a short <code>makeNFD</code> function that does
      three things. First, it checks whether the input meets certain criteria
      that obviate the need for any decomposition. (FCD is short for “fast
      NFC/NFD.”) We can set aside the details of this part for the time being.
      Second, in case NFD conversion <em>is</em> needed, we decompose the input
      code points. Finally, we ensure that the decomposed code points are in
      their canonical ordering.
    </p>
    <p>
      Sounds easy, doesn’t it? But let’s have a look at the
      <code>decompose</code> function. I’ve added comments for clarity.
    </p>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode zig"
      ><code class="sourceCode zig"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> decompose(coll<span class="op">:</span> <span class="op">*</span>Collator<span class="op">,</span> input<span class="op">:</span> <span class="op">*</span>std<span class="op">.</span>ArrayList(<span class="dt">u32</span>)) <span class="op">!</span><span class="dt">void</span> {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">var</span> i<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>   <span class="co">// We need to manage i manually in this loop</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> (i <span class="op">&lt;</span> input<span class="op">.</span>items<span class="op">.</span>len) {</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> code_point <span class="op">=</span> input<span class="op">.</span>items[i];</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Code points below a certain value never require decomposition</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (code_point <span class="op">&lt;</span> <span class="dv">0</span><span class="er">xC0</span>) {</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>         i <span class="op">+=</span> <span class="dv">1</span>;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>         <span class="cf">continue</span>;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Certain Korean text requires special handling; don&#39;t ask</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (<span class="dv">0</span><span class="er">xAC00</span> <span class="op">&lt;=</span> code_point <span class="kw">and</span> code_point <span class="op">&lt;=</span> <span class="dv">0</span><span class="er">xD7A3</span>) {</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> len<span class="op">,</span> <span class="at">const</span> arr <span class="op">=</span> decomposeJamo(code_point);</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>         <span class="cf">try</span> input<span class="op">.</span>replaceRange(i<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> arr[<span class="dv">0</span><span class="op">..</span>len]);</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>         i <span class="op">+=</span> len;</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>         <span class="cf">continue</span>;</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">// If a canonical decomposition exists for this code point, apply it</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (<span class="cf">try</span> coll<span class="op">.</span>getDecomp(code_point)) <span class="op">|</span>decomp<span class="op">|</span> {</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>         <span class="cf">try</span> input<span class="op">.</span>replaceRange(i<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> decomp);</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>         i <span class="op">+=</span> decomp<span class="op">.</span>len;</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>         <span class="cf">continue</span>;</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>      i <span class="op">+=</span> <span class="dv">1</span>;</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>
      The only trick here, apart from the weird Korean stuff, is that we need an
      efficient way of fetching the canonical decomposition (if any) of a given
      code point. I did this in a naïve but functional way, by building a hash
      table from Unicode data. All that my <code>getDecomp</code> function does
      is to check in that table. (The crazier part is that is that I have a
      bunch of data structures like this that are derived from Unicode data, and
      for performance reasons I have them serialized in binary formats. These
      maps are in some cases large, up to a few hundred KiB on disk, but they
      can be loaded rapidly at runtime, and a given collator instance needs to
      do so only once.)
    </p>
    <p>
      Once decomposition has been accomplished, all that is left for NFD is to
      fix the order of the code points so that it matches what is expected
      canonically in the Unicode standard. This is governed by a property called
      “canonical combining class.” In the case of what we might refer to as
      <em>base letters</em>, the combining class is 0, i.e., “not reordered.”
      Such code points are never moved in normalization. Diacritics, on the
      other hand, have a variety of nonzero combining class values; and when
      they appear next to one another in a sequence, they must be in order of
      ascending combining class. The most common scenario in which this might
      become an issue is when a letter has two or more diacritics attached to
      it. I can say from my own academic background that this happens with some
      frequency in Arabic text. There is a diacritic called <em>shadda</em>,
      which serves to add emphasis to a consonant; and there are other
      diacritics that serve as short vowel marks. It is by no means uncommon to
      see an Arabic letter that has both a <em>shadda</em> and a vowel mark
      above it. In such cases, the base letter would have a combining class of
      0, and the multiple diacritics should, ideally, be set in order of
      ascending combining class. Let’s look at an example:
    </p>
    <div class="sourceCode" id="cb19">
      <pre
        class="sourceCode default"
      ><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>U+0628 # Arabic letter bā’, CCC 0</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>U+064E # Arabic vowel fatḥa, CCC 30</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>U+0651 # Arabic shadda, CCC 33</span></code></pre>
    </div>
    <p>
      The above sequence meets the criteria of form NFD. Note that it is
      <em>entirely conceivable</em> that someone might type the
      <em>shadda</em> before the <em>fatḥa</em>; I do so myself. In that case,
      reordering would be needed for NFD to be achieved, and by extension for
      Unicode collation.
    </p>
    <p>
      The last thing that I’ll show here is my <code>reorder</code> function,
      mostly because it takes the form of a modified bubble sort, which amuses
      me. In my several years of work as a programmer, this is the only context
      in which I’ve been compelled to use everyone’s favorite inefficient
      sorting algorithm. Comments are added for clarity.
    </p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode zig"
      ><code class="sourceCode zig"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reorder(input<span class="op">:</span> []<span class="dt">u32</span>) <span class="dt">void</span> {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">var</span> n <span class="op">=</span> input<span class="op">.</span>len;</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> (n <span class="op">&gt;</span> <span class="dv">1</span>) {</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">var</span> new_n<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      <span class="at">var</span> i<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">// We compare two code points at a time</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> (i <span class="op">&lt;</span> n) {</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> cc_b <span class="op">=</span> ccc<span class="op">.</span>getCombiningClass(input[i]);</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>         <span class="co">// If the second code point has CCC 0, we can advance by 2</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> (cc_b <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">2</span>;</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span>;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> cc_a <span class="op">=</span> ccc<span class="op">.</span>getCombiningClass(input[i <span class="op">-</span> <span class="dv">1</span>]);</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>         <span class="co">// The first code point should have CCC 0 or &lt;= cc_b</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> (cc_a <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> cc_a <span class="op">&lt;=</span> cc_b) {</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span>;</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span>;</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>         <span class="co">// This means the check failed, and a swap is needed</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>         std<span class="op">.</span>mem<span class="op">.</span>swap(<span class="dt">u32</span><span class="op">,</span> <span class="op">&amp;</span>input[i <span class="op">-</span> <span class="dv">1</span>]<span class="op">,</span> <span class="op">&amp;</span>input[i]);</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>         <span class="co">// We use a small optimization to avoid rechecking sorted ranges</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>         new_n <span class="op">=</span> i;</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>         i <span class="op">+=</span> <span class="dv">1</span>;</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>      n <span class="op">=</span> new_n;</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>
      As you can see, this relies on repeated calls of
      <code>getCombiningClass</code>. I found, while benchmarking my UCA
      implementation, that looking up combining classes is one of the hottest
      paths in the entire library. It demands a special degree of optimization,
      which is an interesting problem but beyond the scope of this post.
    </p>
    <p><em>To be continued…</em></p>
  </body>
</html>
